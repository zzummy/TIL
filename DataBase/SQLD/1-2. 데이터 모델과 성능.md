# 2장 데이터 모델과 성능

​      

### 성능 데이터 모델링 

- 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항(정규화, 반정규화, 테이블 통합, 테이블 분할, 조인구조, PK, FK 등)이 데이터 모델링에 반영될 수 있도록 하는 것

- 데이터의 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가함
- 데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있음
- 분석/설계 단계에서 성능을 고려한 데이터 모델링을 수행할 경우 성능 저하에 따른 Rework 비용을 최소화 할 수 있는 기회를 가지게 됨

​      

### 성능 데이터 모델링 프로세스

1. 데이터모델링을 할 때 **정규화**를 정확하게 수행
2. 데이터베이스 **용량산정**을 수행
3. 데이터베이스에 발생되는 **트랜잭션의 유형을 파악**
4. 용량과 트랜잭션의 유형에 따라 **반정규화(역정규화)**를 수행
5. 이력모델의 조정, PF/FK 조정, 슈퍼타입/서브타입 조정 등을 수행
6. 성능 관점에서 데이터 모델 검증

​      

---

​      

### 정규화

- 데이터의 중복을 최소화하며 설계하는 기법
- 데이터를 결정하는 결정자에 의해 함수적 종속을 가진 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거
  - 함수적 종속 : 데이터들이 어떤 기준값에 의해 종속되는 현상
- 한 테이블에 인덱스가 많아지면 조회 성능 향상, 입력/수정/삭제 성능 저하

​      

### 정규화의 종류

1. 제 1 정규형

   - 모든 속성은 반드시 하나의 값을 가져야 함

2. 제 2 정규형

   - 부분 함수 종속을 제거하고 모든 속성이 기본키에 완전 함수 종속되도록 분해해야함

     - 부분 함수 종속

       기본키가 복합키일 경우, 기본키를 구성하는 속성 중 일부에게 종속된 경우

   - 엔티티의 일반 속성은 주식별자 전체에 종속적이어야 함

3. 제 3 정규형

   - 모든 속성이 기본키에 이행적 함수 종속이 되지 않도록 분해

     - 이행적 함수 종속 

       X → Y, Y → Z의 종속 관계가 있을 경우, X → Z가 성립되는 것

       즉, X를 알면 Y를 알고, 그를 통해 Z를 알 수 있는 경우

   - 엔티티의 일반 속성 간에는 서로 종속적이지 않음

4. 보이스/코드 정규형 (BCNF)

   - 하나의 릴레이션에 여러 개의 후보키가 존재하는 경우 이상 현상 발생
   - 함수 종속 관계에서 모든 결정자가 후보키가 아닌

5. 제 4 정규형

   - 릴레이션이 보이스/코드 정규형을 만족하면서, 함수 종속이 아닌 다치 종속(MVC, Multi Valued Dependecy)을 제거하면 제 4 정규형에 속함 

6. 제 5 정규형

   - 모든 릴레이션이 제5정규형에 속해야만 바람직한 것은 아님
   - 일반적으로 제3정규형이나, 보이스/코드 정규형에 속하도록 릴레이션을 분해하여 데이터 중복을 줄이고 이상현상을 해결하는 경우가 많음

​      

### 반정규화(역정규화)

- 성능을 위해 데이터 중복을 허용하는 것

- 반정규화만이 조회 성능을 향상시키는 것은 아님 (정규화를 해야 향상되는 경우 존재)

- 입력/수정/삭제 성능 저하

- 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발, 운영의 단순화를 위해 중복,통합,분리 등을 수행하는 기법

- 데이터 무결성이 깨질 수 있는 위험 존재

  하지만 데이터 조회 시 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능 저하가 예상될 경우 수행

- 정규화의 함수적 종속관계는 위반하지 않지만 데이터 중복성을 증가시켜 조회 성능 향상

​      

### 반정규화 적용 방법

1. 반정규화 대상 조사 : **데이터 양 조사, 성능 저하 예측**

   - 범위 처리 빈도수 조사
   - 대량의 범위 처리 조사
   - 통계성 프로세스 조사
   - 테이블 조인 개수 조사

2. 다른 방법 유도 검토 : 데이터 무결성 깨뜨릴 위험 제어

   - **많은 조인** -> **뷰 테이블 이용** 검토

   - 대량의 데이터 처리, 부분처리로 인한 성능 저하 -> **클러스터링 적용, **인덱스 조정**

     - 클러스터링 적용 방법

       대량의 데이터를 특정 클러스터링 팩트에 의해 **저장방식을 다르게** 하는 방법

       데이터 입력/수정/삭제하는 경우 성능이 많이 저하되므로, 

       조회가 대부분이고 인덱스 조정이 불가능하다면 고려할 만함

   - 대량의 데이터 -> PK의 성격에 따라 테이블로 분리 즉, **파티셔닝 기법** 적용

     - 파티셔닝 기법

       특정 기준(파티셔닝 키)에 의해 다르게 저장되고 파티셔닝 키에 따른 조회가 될 때 성능이 좋아짐

   - 응용 애플리케이션 로직 구사 방법 변경

3. 반정규화 적용 : **테이블, 속성, 관계 고려**

​      

### 반정규화 기법

1. 테이블의 반정규화

   - 테이블 병합 

     - 조인되는 경우가 많아 테이블을 합치는 것이 성능향상에 효율적일 경우 적용

     - 1:1, 1:M, 슈퍼/서브타입 테이블 병합

   - 테이블 분할

     - 분할된 테이블의 전체 조회 시 union을 사용해야 하므로 성능이 느려질 경우 적용

     - 수직 분할 (칼럼 단위, 1:1 관계)

     - 수평 분할 (로우 단위, 관계 엾음)

       → 디스크 I/O 분산, 데이터 접근 효율성

   - 테이블 추가

     - 논리적인 모델링이 끝난 후 추가적으로 통계 산출 발생 시 통계 테이블을 추가하여 테이블을 산출 
     - 중복, 통계, 이력, 부분 테이블 추가

2. 칼럼의 반정규화

   - 중복칼럼 추가 : 조인 감소를 위해 여러 테이블에 동일한 칼럼 갖도록
   - 파생칼럼 추가 : 조회 성능을 우수하게 하기 위해 미리 계산된 칼럼을 갖도록
   - 이력테이블 칼럼 추가
   - PK에 의한 칼럼 추가 : 단일 속성의 PK에서 특정 값을 별도로 조회하는 경우, 일반 속성으로 포함
   - 응용시스템 오작동을 위한 칼럼 추가 : 이전 데이터 임시 중복 저장

​      

### 대량의 데이터에 따른 테이블 분할

- 한 테이블에 많은 칼럼들이 존재할 경우 데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 디스크 I/O가 대량으로 발생할 수 있고, 이로 인해 성능이 저하될 수 있음

- 로우체이닝 (Row Chaining)

  로우의 길이가 너무 길어서 데이트 블록 하나에 데이터를 모두 저장하지 않고 두 개 이상의 블록에 걸쳐서 하나의 로우가 저장되는 형태

- 로우마이그레이션 (Row Migration)

  데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

- 해결방법

  - 트랜잭션이 접근하는 칼럼유형 분석 

    → 자주 접근하는 칼럼들과 상대적으로 접근 빈도가 낮은 칼럼들 구분해 1:1로 테이블을 분리함

    → 디스크 I/O가 줄어들어 성능을 향상시킬 수 있음

  - **파티셔닝**

​         

### 파티셔닝

````
테이블 또는 인덱스 데이터를 파티션 단위로 나누어 저장하는 것
````

- 종류

  1. Range 파티션 (범위 지정)

     - 대상 테이블이 날짜/숫자값으로 분리가 가능하고, 각 영역별로 트랜잭션이 분리되면 적용 가능 

     - 데이터 보관 주기에 따라 테이블에 데이터를 쉽게 지우는 것(**파티션 테이블 DROP**)이 가능하므로

       **데이터 보관 주기에 따른 테이블 관리가 용이**

  2. List 파티션 (특정 값 지정)

     - 대용량의 데이터를 **특정 값에 따라 분리, 저장**하는 기법

       핵심적인 코드값 등으로 기본키가 구성되어 있고, 대량의 데이터가 있는 곳에서 사용 가능

     - Range 파티션과 같이 데이터 보관 주기에 따라 쉽게 삭제하는 기능을 제공하지 않음

  3. Hast 파티션 (해시 적용)

     - 지정된 HASH 조건에 따라 해싱 알고리즘이 적용되어 테이블이 분리됨
     - 설계자는 테이블에 데이터가 **정확하게 어떻게 들어갔는지 알 수 없음**
     - **성능 향상**을 위해 사용됨
     - Range 파티션과 같이 데이터 보관 주기에 따라 쉽게 삭제하는 기능을 제공

​         

### 슈퍼/서브 타입 데이터 모델

- Extended ER모델
- 공통의 부분을 슈퍼타입으로 모델링, 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해서는 별도의 서브 엔티티로 구분하여 업무의 모습을 정확하게 표현
- 슈퍼/서브 타입에 대한 변환 잘못하면 성능 저하 (트랜잭션 특성 고려하지 않음)
  - 트랜잭션은 **항상 일괄로 처리**하는데 **테이블은 개별로 유지**되어 **union 연산에 의해 성능 저하**
  - 트랜잭션은 **항상 서브타입 개별로 처리**하는데 **테이블은 하나로 통합**되어 있어 **불필요하게 많은 양의 데이터** 때문에 성능 저하
  - 트랜잭션은 **항상 슈퍼+서브타입을 공통으로 처리**하는데 **개별로 유지**되어 있거나 **하나의 테이블로 집약**되어있어 성능 저하

- 변환 기술 : 트랜잭션의 유형과 데이터의 양 고려

  1. One to One Type (1:1 타입)

     개별로 발생되는 트랙잭션에 대해서는 개별 테이블로 구성

  2. Plus Type (슈퍼+서브타입)

     슈퍼+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼+서브타입 테이블로 구성

  3. Single Type (All in One 타입)

     전체를 하나로 묶어 트랜잭션이 발생할 떄는 하나의 테이블로 구성 

​    

+) **트랜잭션** : 데이터베이스의 논리적 연산 단위

​          

### 인덱스 특성

```
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
```

- PK/FK 칼럼 순서 조정
  - 앞쪽에 위치한 속성의 값이 비교자로 있어야 좋은 인덱스 효율
  - 값의 범위에 따라 일정하게 정렬되어 있으므로 상수값으로 '=' 으로 조회되는 칼럼이 가장 앞
  - 범위조회하는 'BETWEEN', '<>'로 조회되는 칼럼이 그 다음
  - FK에 대해 반드시 인덱스 생성

​         

### 분산 데이터베이스

```
- 여러 곳으로 분산되어있는 데이터베이스를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터 베이스
- 논리적으로 동일한 시스템, 물리적으로 분산되어 있는 데이터
```

- 투명성

  - 분할 투명성(단편화) : 하나의 논리적 릴레이션이 여러 단편으로 분할되어 각 사본이 여러 사이트에 저장
  - 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요, 위치정보가 시스템 카탈로그에 유지
  - 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 매핑 보장
  - 중복 투명성 : DB 객체가 여러 사이트에 중복 되어 있는지 알 필요가 없는 성질
  - 장애 투명성 : 구성요소의 장애에 무관한 트랜잭션의 원자성 유지
  - 병행 투명성 : 다수 트랜잭션 동시 수행시 결과의 일관성 유지, TimeStamp, 분산 2단계 Locking 이용

- 장점

  - 지역 자치성, 점증적 시스템 용량 확장
  - 신뢰성, 가용성, 효용성, 융통성
  - 빠른 응답 속도, 통신 비용 절감, 시스템 규모의 적절한 조절, 각 지역 사용자의 요구 수용 증대

- 단점

  - 소프트웨어 개발 비용
  - 오류의 잠재성 증대
  - 처리 비용의 증대
  - 설계, 관리의 복잡성과 비용
  - 불규칙한 응답 속도
  - 통제의 어려움
  - 데이터 무결성에 대한 위협

- 적용 기법

  - 테이블 위치 분산 
    - 테이블 구조 변경 없음, 중복 없음, 위치만 다름 -> 도식화된 위치별 데이터베이스 문서 필요
  - 테이블 분할 분산 
    - 각각의 테이블을 쪼개어 분산, 지사별로 별도로 존재, 데이터 중복 없음, 데이터 무결성 보장, 조인 필요
    - 수평 분할, 수직 분할
  - 테이블 복제 분산
    - 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리
    - 부분 복제 : 마스터 DB에서 테이블의 일부 내용만 다른 지역이나 서버에 위치
    - 광역 복제 : 마스터 DB  테이블의 내용을 각 지역이나 서버에 존재
  - 테이블 요약 분산
    - 지역 간에 또는 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재
    - 분석 요약 : 동일한 테이블 구조로 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출
    - 통합 요약 : 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출

- 분산 DB 설계를 고려해야 하는 경우

  1. **성능**이 중요한 사이트

  2. **공통코드, 기준정보, 마스터 데이터의 성능향상**

  3. 거의 **실시간 업무적인 특성**을 가지고 있을 때

  4. 특정 서버에 부하가 집중되어 부하를 분산

  5. **백업 사이트** 구성하는 경우

- Global Single Instance(GSI)
  - 통합된 한 개의 인스턴스 즉, 통합 데이터베이스 구조 => 분산 데이터베이스와 대치되는 개념